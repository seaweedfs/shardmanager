// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: shardmanager.proto

package shardmanagerpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NodeService_RegisterNode_FullMethodName = "/shardmanagerpb.NodeService/RegisterNode"
	NodeService_Heartbeat_FullMethodName    = "/shardmanagerpb.NodeService/Heartbeat"
	NodeService_ListNodes_FullMethodName    = "/shardmanagerpb.NodeService/ListNodes"
)

// NodeServiceClient is the client API for NodeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeServiceClient interface {
	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
}

type nodeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeServiceClient(cc grpc.ClientConnInterface) NodeServiceClient {
	return &nodeServiceClient{cc}
}

func (c *nodeServiceClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNodeResponse)
	err := c.cc.Invoke(ctx, NodeService_RegisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, NodeService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNodesResponse)
	err := c.cc.Invoke(ctx, NodeService_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServiceServer is the server API for NodeService service.
// All implementations must embed UnimplementedNodeServiceServer
// for forward compatibility.
type NodeServiceServer interface {
	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
	mustEmbedUnimplementedNodeServiceServer()
}

// UnimplementedNodeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeServiceServer struct{}

func (UnimplementedNodeServiceServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedNodeServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedNodeServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedNodeServiceServer) mustEmbedUnimplementedNodeServiceServer() {}
func (UnimplementedNodeServiceServer) testEmbeddedByValue()                     {}

// UnsafeNodeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServiceServer will
// result in compilation errors.
type UnsafeNodeServiceServer interface {
	mustEmbedUnimplementedNodeServiceServer()
}

func RegisterNodeServiceServer(s grpc.ServiceRegistrar, srv NodeServiceServer) {
	// If the following call pancis, it indicates UnimplementedNodeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeService_ServiceDesc, srv)
}

func _NodeService_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServiceServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeService_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeService_ServiceDesc is the grpc.ServiceDesc for NodeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shardmanagerpb.NodeService",
	HandlerType: (*NodeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNode",
			Handler:    _NodeService_RegisterNode_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _NodeService_Heartbeat_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _NodeService_ListNodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shardmanager.proto",
}

const (
	ShardService_RegisterShard_FullMethodName     = "/shardmanagerpb.ShardService/RegisterShard"
	ShardService_ListShards_FullMethodName        = "/shardmanagerpb.ShardService/ListShards"
	ShardService_GetShardInfo_FullMethodName      = "/shardmanagerpb.ShardService/GetShardInfo"
	ShardService_AssignShard_FullMethodName       = "/shardmanagerpb.ShardService/AssignShard"
	ShardService_MigrateShard_FullMethodName      = "/shardmanagerpb.ShardService/MigrateShard"
	ShardService_UpdateShardStatus_FullMethodName = "/shardmanagerpb.ShardService/UpdateShardStatus"
)

// ShardServiceClient is the client API for ShardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShardServiceClient interface {
	RegisterShard(ctx context.Context, in *RegisterShardRequest, opts ...grpc.CallOption) (*RegisterShardResponse, error)
	ListShards(ctx context.Context, in *ListShardsRequest, opts ...grpc.CallOption) (*ListShardsResponse, error)
	GetShardInfo(ctx context.Context, in *GetShardInfoRequest, opts ...grpc.CallOption) (*GetShardInfoResponse, error)
	AssignShard(ctx context.Context, in *AssignShardRequest, opts ...grpc.CallOption) (*AssignShardResponse, error)
	MigrateShard(ctx context.Context, in *MigrateShardRequest, opts ...grpc.CallOption) (*MigrateShardResponse, error)
	UpdateShardStatus(ctx context.Context, in *UpdateShardStatusRequest, opts ...grpc.CallOption) (*UpdateShardStatusResponse, error)
}

type shardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewShardServiceClient(cc grpc.ClientConnInterface) ShardServiceClient {
	return &shardServiceClient{cc}
}

func (c *shardServiceClient) RegisterShard(ctx context.Context, in *RegisterShardRequest, opts ...grpc.CallOption) (*RegisterShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterShardResponse)
	err := c.cc.Invoke(ctx, ShardService_RegisterShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardServiceClient) ListShards(ctx context.Context, in *ListShardsRequest, opts ...grpc.CallOption) (*ListShardsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListShardsResponse)
	err := c.cc.Invoke(ctx, ShardService_ListShards_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardServiceClient) GetShardInfo(ctx context.Context, in *GetShardInfoRequest, opts ...grpc.CallOption) (*GetShardInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetShardInfoResponse)
	err := c.cc.Invoke(ctx, ShardService_GetShardInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardServiceClient) AssignShard(ctx context.Context, in *AssignShardRequest, opts ...grpc.CallOption) (*AssignShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AssignShardResponse)
	err := c.cc.Invoke(ctx, ShardService_AssignShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardServiceClient) MigrateShard(ctx context.Context, in *MigrateShardRequest, opts ...grpc.CallOption) (*MigrateShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateShardResponse)
	err := c.cc.Invoke(ctx, ShardService_MigrateShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardServiceClient) UpdateShardStatus(ctx context.Context, in *UpdateShardStatusRequest, opts ...grpc.CallOption) (*UpdateShardStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateShardStatusResponse)
	err := c.cc.Invoke(ctx, ShardService_UpdateShardStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShardServiceServer is the server API for ShardService service.
// All implementations must embed UnimplementedShardServiceServer
// for forward compatibility.
type ShardServiceServer interface {
	RegisterShard(context.Context, *RegisterShardRequest) (*RegisterShardResponse, error)
	ListShards(context.Context, *ListShardsRequest) (*ListShardsResponse, error)
	GetShardInfo(context.Context, *GetShardInfoRequest) (*GetShardInfoResponse, error)
	AssignShard(context.Context, *AssignShardRequest) (*AssignShardResponse, error)
	MigrateShard(context.Context, *MigrateShardRequest) (*MigrateShardResponse, error)
	UpdateShardStatus(context.Context, *UpdateShardStatusRequest) (*UpdateShardStatusResponse, error)
	mustEmbedUnimplementedShardServiceServer()
}

// UnimplementedShardServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShardServiceServer struct{}

func (UnimplementedShardServiceServer) RegisterShard(context.Context, *RegisterShardRequest) (*RegisterShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterShard not implemented")
}
func (UnimplementedShardServiceServer) ListShards(context.Context, *ListShardsRequest) (*ListShardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListShards not implemented")
}
func (UnimplementedShardServiceServer) GetShardInfo(context.Context, *GetShardInfoRequest) (*GetShardInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShardInfo not implemented")
}
func (UnimplementedShardServiceServer) AssignShard(context.Context, *AssignShardRequest) (*AssignShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignShard not implemented")
}
func (UnimplementedShardServiceServer) MigrateShard(context.Context, *MigrateShardRequest) (*MigrateShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateShard not implemented")
}
func (UnimplementedShardServiceServer) UpdateShardStatus(context.Context, *UpdateShardStatusRequest) (*UpdateShardStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShardStatus not implemented")
}
func (UnimplementedShardServiceServer) mustEmbedUnimplementedShardServiceServer() {}
func (UnimplementedShardServiceServer) testEmbeddedByValue()                      {}

// UnsafeShardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShardServiceServer will
// result in compilation errors.
type UnsafeShardServiceServer interface {
	mustEmbedUnimplementedShardServiceServer()
}

func RegisterShardServiceServer(s grpc.ServiceRegistrar, srv ShardServiceServer) {
	// If the following call pancis, it indicates UnimplementedShardServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ShardService_ServiceDesc, srv)
}

func _ShardService_RegisterShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServiceServer).RegisterShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShardService_RegisterShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServiceServer).RegisterShard(ctx, req.(*RegisterShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardService_ListShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServiceServer).ListShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShardService_ListShards_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServiceServer).ListShards(ctx, req.(*ListShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardService_GetShardInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShardInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServiceServer).GetShardInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShardService_GetShardInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServiceServer).GetShardInfo(ctx, req.(*GetShardInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardService_AssignShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServiceServer).AssignShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShardService_AssignShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServiceServer).AssignShard(ctx, req.(*AssignShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardService_MigrateShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServiceServer).MigrateShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShardService_MigrateShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServiceServer).MigrateShard(ctx, req.(*MigrateShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardService_UpdateShardStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateShardStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardServiceServer).UpdateShardStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShardService_UpdateShardStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardServiceServer).UpdateShardStatus(ctx, req.(*UpdateShardStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShardService_ServiceDesc is the grpc.ServiceDesc for ShardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shardmanagerpb.ShardService",
	HandlerType: (*ShardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterShard",
			Handler:    _ShardService_RegisterShard_Handler,
		},
		{
			MethodName: "ListShards",
			Handler:    _ShardService_ListShards_Handler,
		},
		{
			MethodName: "GetShardInfo",
			Handler:    _ShardService_GetShardInfo_Handler,
		},
		{
			MethodName: "AssignShard",
			Handler:    _ShardService_AssignShard_Handler,
		},
		{
			MethodName: "MigrateShard",
			Handler:    _ShardService_MigrateShard_Handler,
		},
		{
			MethodName: "UpdateShardStatus",
			Handler:    _ShardService_UpdateShardStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shardmanager.proto",
}

const (
	PolicyService_SetPolicy_FullMethodName = "/shardmanagerpb.PolicyService/SetPolicy"
	PolicyService_GetPolicy_FullMethodName = "/shardmanagerpb.PolicyService/GetPolicy"
)

// PolicyServiceClient is the client API for PolicyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PolicyServiceClient interface {
	SetPolicy(ctx context.Context, in *SetPolicyRequest, opts ...grpc.CallOption) (*SetPolicyResponse, error)
	GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error)
}

type policyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPolicyServiceClient(cc grpc.ClientConnInterface) PolicyServiceClient {
	return &policyServiceClient{cc}
}

func (c *policyServiceClient) SetPolicy(ctx context.Context, in *SetPolicyRequest, opts ...grpc.CallOption) (*SetPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetPolicyResponse)
	err := c.cc.Invoke(ctx, PolicyService_SetPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyServiceClient) GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPolicyResponse)
	err := c.cc.Invoke(ctx, PolicyService_GetPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicyServiceServer is the server API for PolicyService service.
// All implementations must embed UnimplementedPolicyServiceServer
// for forward compatibility.
type PolicyServiceServer interface {
	SetPolicy(context.Context, *SetPolicyRequest) (*SetPolicyResponse, error)
	GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error)
	mustEmbedUnimplementedPolicyServiceServer()
}

// UnimplementedPolicyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPolicyServiceServer struct{}

func (UnimplementedPolicyServiceServer) SetPolicy(context.Context, *SetPolicyRequest) (*SetPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPolicy not implemented")
}
func (UnimplementedPolicyServiceServer) GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPolicy not implemented")
}
func (UnimplementedPolicyServiceServer) mustEmbedUnimplementedPolicyServiceServer() {}
func (UnimplementedPolicyServiceServer) testEmbeddedByValue()                       {}

// UnsafePolicyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PolicyServiceServer will
// result in compilation errors.
type UnsafePolicyServiceServer interface {
	mustEmbedUnimplementedPolicyServiceServer()
}

func RegisterPolicyServiceServer(s grpc.ServiceRegistrar, srv PolicyServiceServer) {
	// If the following call pancis, it indicates UnimplementedPolicyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PolicyService_ServiceDesc, srv)
}

func _PolicyService_SetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServiceServer).SetPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PolicyService_SetPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServiceServer).SetPolicy(ctx, req.(*SetPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyService_GetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyServiceServer).GetPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PolicyService_GetPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyServiceServer).GetPolicy(ctx, req.(*GetPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PolicyService_ServiceDesc is the grpc.ServiceDesc for PolicyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PolicyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shardmanagerpb.PolicyService",
	HandlerType: (*PolicyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPolicy",
			Handler:    _PolicyService_SetPolicy_Handler,
		},
		{
			MethodName: "GetPolicy",
			Handler:    _PolicyService_GetPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shardmanager.proto",
}

const (
	MonitoringService_GetDistribution_FullMethodName = "/shardmanagerpb.MonitoringService/GetDistribution"
	MonitoringService_GetHealth_FullMethodName       = "/shardmanagerpb.MonitoringService/GetHealth"
)

// MonitoringServiceClient is the client API for MonitoringService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MonitoringServiceClient interface {
	GetDistribution(ctx context.Context, in *GetDistributionRequest, opts ...grpc.CallOption) (*GetDistributionResponse, error)
	GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*GetHealthResponse, error)
}

type monitoringServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMonitoringServiceClient(cc grpc.ClientConnInterface) MonitoringServiceClient {
	return &monitoringServiceClient{cc}
}

func (c *monitoringServiceClient) GetDistribution(ctx context.Context, in *GetDistributionRequest, opts ...grpc.CallOption) (*GetDistributionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDistributionResponse)
	err := c.cc.Invoke(ctx, MonitoringService_GetDistribution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringServiceClient) GetHealth(ctx context.Context, in *GetHealthRequest, opts ...grpc.CallOption) (*GetHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHealthResponse)
	err := c.cc.Invoke(ctx, MonitoringService_GetHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MonitoringServiceServer is the server API for MonitoringService service.
// All implementations must embed UnimplementedMonitoringServiceServer
// for forward compatibility.
type MonitoringServiceServer interface {
	GetDistribution(context.Context, *GetDistributionRequest) (*GetDistributionResponse, error)
	GetHealth(context.Context, *GetHealthRequest) (*GetHealthResponse, error)
	mustEmbedUnimplementedMonitoringServiceServer()
}

// UnimplementedMonitoringServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonitoringServiceServer struct{}

func (UnimplementedMonitoringServiceServer) GetDistribution(context.Context, *GetDistributionRequest) (*GetDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDistribution not implemented")
}
func (UnimplementedMonitoringServiceServer) GetHealth(context.Context, *GetHealthRequest) (*GetHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedMonitoringServiceServer) mustEmbedUnimplementedMonitoringServiceServer() {}
func (UnimplementedMonitoringServiceServer) testEmbeddedByValue()                           {}

// UnsafeMonitoringServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonitoringServiceServer will
// result in compilation errors.
type UnsafeMonitoringServiceServer interface {
	mustEmbedUnimplementedMonitoringServiceServer()
}

func RegisterMonitoringServiceServer(s grpc.ServiceRegistrar, srv MonitoringServiceServer) {
	// If the following call pancis, it indicates UnimplementedMonitoringServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonitoringService_ServiceDesc, srv)
}

func _MonitoringService_GetDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServiceServer).GetDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonitoringService_GetDistribution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServiceServer).GetDistribution(ctx, req.(*GetDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonitoringService_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServiceServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonitoringService_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServiceServer).GetHealth(ctx, req.(*GetHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MonitoringService_ServiceDesc is the grpc.ServiceDesc for MonitoringService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonitoringService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shardmanagerpb.MonitoringService",
	HandlerType: (*MonitoringServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDistribution",
			Handler:    _MonitoringService_GetDistribution_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _MonitoringService_GetHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shardmanager.proto",
}

const (
	FailureService_ReportFailure_FullMethodName = "/shardmanagerpb.FailureService/ReportFailure"
)

// FailureServiceClient is the client API for FailureService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FailureServiceClient interface {
	ReportFailure(ctx context.Context, in *ReportFailureRequest, opts ...grpc.CallOption) (*ReportFailureResponse, error)
}

type failureServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFailureServiceClient(cc grpc.ClientConnInterface) FailureServiceClient {
	return &failureServiceClient{cc}
}

func (c *failureServiceClient) ReportFailure(ctx context.Context, in *ReportFailureRequest, opts ...grpc.CallOption) (*ReportFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportFailureResponse)
	err := c.cc.Invoke(ctx, FailureService_ReportFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FailureServiceServer is the server API for FailureService service.
// All implementations must embed UnimplementedFailureServiceServer
// for forward compatibility.
type FailureServiceServer interface {
	ReportFailure(context.Context, *ReportFailureRequest) (*ReportFailureResponse, error)
	mustEmbedUnimplementedFailureServiceServer()
}

// UnimplementedFailureServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFailureServiceServer struct{}

func (UnimplementedFailureServiceServer) ReportFailure(context.Context, *ReportFailureRequest) (*ReportFailureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportFailure not implemented")
}
func (UnimplementedFailureServiceServer) mustEmbedUnimplementedFailureServiceServer() {}
func (UnimplementedFailureServiceServer) testEmbeddedByValue()                        {}

// UnsafeFailureServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FailureServiceServer will
// result in compilation errors.
type UnsafeFailureServiceServer interface {
	mustEmbedUnimplementedFailureServiceServer()
}

func RegisterFailureServiceServer(s grpc.ServiceRegistrar, srv FailureServiceServer) {
	// If the following call pancis, it indicates UnimplementedFailureServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FailureService_ServiceDesc, srv)
}

func _FailureService_ReportFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FailureServiceServer).ReportFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FailureService_ReportFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FailureServiceServer).ReportFailure(ctx, req.(*ReportFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FailureService_ServiceDesc is the grpc.ServiceDesc for FailureService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FailureService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shardmanagerpb.FailureService",
	HandlerType: (*FailureServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportFailure",
			Handler:    _FailureService_ReportFailure_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shardmanager.proto",
}

const (
	AppShardService_AddShard_FullMethodName         = "/shardmanagerpb.AppShardService/AddShard"
	AppShardService_DropShard_FullMethodName        = "/shardmanagerpb.AppShardService/DropShard"
	AppShardService_ChangeRole_FullMethodName       = "/shardmanagerpb.AppShardService/ChangeRole"
	AppShardService_PrepareAddShard_FullMethodName  = "/shardmanagerpb.AppShardService/PrepareAddShard"
	AppShardService_PrepareDropShard_FullMethodName = "/shardmanagerpb.AppShardService/PrepareDropShard"
)

// AppShardServiceClient is the client API for AppShardService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Application-server-implemented service, invoked by shardmanager
type AppShardServiceClient interface {
	AddShard(ctx context.Context, in *AddShardRequest, opts ...grpc.CallOption) (*AddShardResponse, error)
	DropShard(ctx context.Context, in *DropShardRequest, opts ...grpc.CallOption) (*DropShardResponse, error)
	ChangeRole(ctx context.Context, in *ChangeRoleRequest, opts ...grpc.CallOption) (*ChangeRoleResponse, error)
	PrepareAddShard(ctx context.Context, in *PrepareAddShardRequest, opts ...grpc.CallOption) (*PrepareAddShardResponse, error)
	PrepareDropShard(ctx context.Context, in *PrepareDropShardRequest, opts ...grpc.CallOption) (*PrepareDropShardResponse, error)
}

type appShardServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAppShardServiceClient(cc grpc.ClientConnInterface) AppShardServiceClient {
	return &appShardServiceClient{cc}
}

func (c *appShardServiceClient) AddShard(ctx context.Context, in *AddShardRequest, opts ...grpc.CallOption) (*AddShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddShardResponse)
	err := c.cc.Invoke(ctx, AppShardService_AddShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appShardServiceClient) DropShard(ctx context.Context, in *DropShardRequest, opts ...grpc.CallOption) (*DropShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropShardResponse)
	err := c.cc.Invoke(ctx, AppShardService_DropShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appShardServiceClient) ChangeRole(ctx context.Context, in *ChangeRoleRequest, opts ...grpc.CallOption) (*ChangeRoleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeRoleResponse)
	err := c.cc.Invoke(ctx, AppShardService_ChangeRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appShardServiceClient) PrepareAddShard(ctx context.Context, in *PrepareAddShardRequest, opts ...grpc.CallOption) (*PrepareAddShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareAddShardResponse)
	err := c.cc.Invoke(ctx, AppShardService_PrepareAddShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appShardServiceClient) PrepareDropShard(ctx context.Context, in *PrepareDropShardRequest, opts ...grpc.CallOption) (*PrepareDropShardResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareDropShardResponse)
	err := c.cc.Invoke(ctx, AppShardService_PrepareDropShard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppShardServiceServer is the server API for AppShardService service.
// All implementations must embed UnimplementedAppShardServiceServer
// for forward compatibility.
//
// Application-server-implemented service, invoked by shardmanager
type AppShardServiceServer interface {
	AddShard(context.Context, *AddShardRequest) (*AddShardResponse, error)
	DropShard(context.Context, *DropShardRequest) (*DropShardResponse, error)
	ChangeRole(context.Context, *ChangeRoleRequest) (*ChangeRoleResponse, error)
	PrepareAddShard(context.Context, *PrepareAddShardRequest) (*PrepareAddShardResponse, error)
	PrepareDropShard(context.Context, *PrepareDropShardRequest) (*PrepareDropShardResponse, error)
	mustEmbedUnimplementedAppShardServiceServer()
}

// UnimplementedAppShardServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAppShardServiceServer struct{}

func (UnimplementedAppShardServiceServer) AddShard(context.Context, *AddShardRequest) (*AddShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddShard not implemented")
}
func (UnimplementedAppShardServiceServer) DropShard(context.Context, *DropShardRequest) (*DropShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropShard not implemented")
}
func (UnimplementedAppShardServiceServer) ChangeRole(context.Context, *ChangeRoleRequest) (*ChangeRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeRole not implemented")
}
func (UnimplementedAppShardServiceServer) PrepareAddShard(context.Context, *PrepareAddShardRequest) (*PrepareAddShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareAddShard not implemented")
}
func (UnimplementedAppShardServiceServer) PrepareDropShard(context.Context, *PrepareDropShardRequest) (*PrepareDropShardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareDropShard not implemented")
}
func (UnimplementedAppShardServiceServer) mustEmbedUnimplementedAppShardServiceServer() {}
func (UnimplementedAppShardServiceServer) testEmbeddedByValue()                         {}

// UnsafeAppShardServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppShardServiceServer will
// result in compilation errors.
type UnsafeAppShardServiceServer interface {
	mustEmbedUnimplementedAppShardServiceServer()
}

func RegisterAppShardServiceServer(s grpc.ServiceRegistrar, srv AppShardServiceServer) {
	// If the following call pancis, it indicates UnimplementedAppShardServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AppShardService_ServiceDesc, srv)
}

func _AppShardService_AddShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppShardServiceServer).AddShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppShardService_AddShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppShardServiceServer).AddShard(ctx, req.(*AddShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppShardService_DropShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppShardServiceServer).DropShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppShardService_DropShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppShardServiceServer).DropShard(ctx, req.(*DropShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppShardService_ChangeRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppShardServiceServer).ChangeRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppShardService_ChangeRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppShardServiceServer).ChangeRole(ctx, req.(*ChangeRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppShardService_PrepareAddShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareAddShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppShardServiceServer).PrepareAddShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppShardService_PrepareAddShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppShardServiceServer).PrepareAddShard(ctx, req.(*PrepareAddShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppShardService_PrepareDropShard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareDropShardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppShardServiceServer).PrepareDropShard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppShardService_PrepareDropShard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppShardServiceServer).PrepareDropShard(ctx, req.(*PrepareDropShardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AppShardService_ServiceDesc is the grpc.ServiceDesc for AppShardService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppShardService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "shardmanagerpb.AppShardService",
	HandlerType: (*AppShardServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddShard",
			Handler:    _AppShardService_AddShard_Handler,
		},
		{
			MethodName: "DropShard",
			Handler:    _AppShardService_DropShard_Handler,
		},
		{
			MethodName: "ChangeRole",
			Handler:    _AppShardService_ChangeRole_Handler,
		},
		{
			MethodName: "PrepareAddShard",
			Handler:    _AppShardService_PrepareAddShard_Handler,
		},
		{
			MethodName: "PrepareDropShard",
			Handler:    _AppShardService_PrepareDropShard_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shardmanager.proto",
}
